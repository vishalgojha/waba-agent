// @ts-nocheck
const fs = require("fs-extra");
const path = require("path");

const { getConfig } = require("../lib/config");
const { logger } = require("../lib/logger");

function mustNotExist(p, { force = false } = {}) {
  return (async () => {
    const exists = await fs.pathExists(p);
    if (exists && !force) throw new Error(`Refusing to overwrite existing path: ${p} (pass --force)`);
  })();
}

function dockerfileText() {
  // Keep it boring and portable. Users can customize base image later.
  return `FROM node:20-alpine
WORKDIR /app

# Install only production deps
COPY package.json package-lock.json* ./
RUN npm ci --omit=dev

COPY . .

ENV NODE_ENV=production
EXPOSE 3000

# Default: webhook receiver (no outbound unless explicitly allowed).
CMD ["node","bin/waba.js","webhook","start","--host","0.0.0.0","--port","3000","--path","/webhook","--verbose"]
`;
}

function composeText({ client, port }) {
  // Uses env vars so you don't have to bake secrets into images.
  return `services:
  waba-agent:
    build: .
    container_name: waba-agent-${client}
    restart: unless-stopped
    ports:
      - "${port}:3000"
    environment:
      - WABA_HOME=/data/.waba
      - WABA_TOKEN=\${WABA_TOKEN}
      - WABA_PHONE_ID=\${WABA_PHONE_ID}
      - WABA_BUSINESS_ID=\${WABA_BUSINESS_ID}
      - WABA_VERIFY_TOKEN=\${WABA_VERIFY_TOKEN}
      - WABA_APP_SECRET=\${WABA_APP_SECRET}
      - OPENAI_API_KEY=\${OPENAI_API_KEY}
      - OPENAI_BASE_URL=\${OPENAI_BASE_URL}
      - WABA_OPENAI_MODEL=\${WABA_OPENAI_MODEL}
      - WABA_OPENAI_VISION_MODEL=\${WABA_OPENAI_VISION_MODEL}
      - WABA_OPENAI_TRANSCRIBE_MODEL=\${WABA_OPENAI_TRANSCRIBE_MODEL}
      - NGROK_AUTHTOKEN=\${NGROK_AUTHTOKEN}
    volumes:
      - ./data:/data
    command:
      - node
      - bin/waba.js
      - webhook
      - start
      - --host
      - 0.0.0.0
      - --port
      - "3000"
      - --path
      - /webhook
      - --client
      - ${client}
      - --verbose
`;
}

function envExampleText() {
  return `# WhatsApp Cloud API creds (required)
WABA_TOKEN=
WABA_PHONE_ID=
WABA_BUSINESS_ID=

# Webhook verification/hardening (recommended)
WABA_VERIFY_TOKEN=
WABA_APP_SECRET=

# Optional: AI
OPENAI_API_KEY=
OPENAI_BASE_URL=
WABA_OPENAI_MODEL=gpt-4o-mini
WABA_OPENAI_VISION_MODEL=gpt-4o-mini
WABA_OPENAI_TRANSCRIBE_MODEL=gpt-4o-mini-transcribe

# Optional: ngrok (dev only; do not use in prod containers)
NGROK_AUTHTOKEN=
`;
}

function deployReadmeText({ client, port }) {
  return `# waba-agent Deploy (Docker)

This folder was generated by \`waba deploy render docker\` for client \`${client}\`.

## Quick Start

1. Copy \`.env.example\` to \`.env\` and fill values.
2. Run:

\`\`\`bash
docker compose up -d --build
\`\`\`

Webhook will listen on:

- http://YOUR_SERVER_IP:${port}/webhook

## Production Notes

- Do not expose the webhook publicly without signature verification (\`WABA_APP_SECRET\`) and network controls.
- Outbound messaging is per-message billed. In production, keep \`--allow-outbound\` OFF by default and enable only after testing.
- Persist state by keeping the \`./data\` volume.
`;
}

function registerDeployCommands(program) {
  const d = program.command("deploy").description("deployment helpers (generate Docker artifacts)");

  d.command("render")
    .description("render deployment artifacts")
    .argument("<provider>", "provider: docker")
    .option("--client <name>", "client name (default: active client)")
    .option("--out <dir>", "output directory", "deploy")
    .option("--port <n>", "host port to expose webhook", (v) => Number(v), 3000)
    .option("--force", "overwrite existing files", false)
    .action(async (provider, opts, cmd) => {
      const root = cmd.parent?.parent || program;
      const { json } = root.opts();
      if (json) throw new Error("--json not supported for deploy render.");
      if (provider !== "docker") throw new Error("Only provider supported right now: docker");

      const cfg = await getConfig();
      const client = opts.client || cfg.activeClient || "default";
      const outDir = path.resolve(process.cwd(), opts.out);

      await fs.ensureDir(outDir);

      const dockerfilePath = path.join(outDir, "Dockerfile");
      const composePath = path.join(outDir, "docker-compose.yml");
      const envPath = path.join(outDir, ".env.example");
      const readmePath = path.join(outDir, "README.md");

      await mustNotExist(dockerfilePath, { force: opts.force });
      await mustNotExist(composePath, { force: opts.force });
      await mustNotExist(envPath, { force: opts.force });
      await mustNotExist(readmePath, { force: opts.force });

      // Copy repo sources into the deploy dir (minimal but reliable).
      // This makes `docker compose build` self-contained from the generated folder.
      // Note: We skip node_modules.
      const copyList = ["bin", "src", "package.json", "package-lock.json", "README.md", "LICENSE"];
      for (const rel of copyList) {
        const srcPath = path.resolve(process.cwd(), rel);
        const dstPath = path.join(outDir, rel);
        if (await fs.pathExists(srcPath)) {
          await fs.copy(srcPath, dstPath, { filter: (p) => !String(p).includes(`${path.sep}node_modules${path.sep}`) });
        }
      }

      await fs.writeFile(dockerfilePath, dockerfileText(), "utf8");
      await fs.writeFile(composePath, composeText({ client, port: opts.port }), "utf8");
      await fs.writeFile(envPath, envExampleText(), "utf8");
      await fs.ensureDir(path.join(outDir, "data"));
      await fs.writeFile(readmePath, deployReadmeText({ client, port: opts.port }), "utf8");

      logger.ok(`Rendered Docker deploy folder: ${outDir}`);
      logger.info("Next:");
      logger.info(`- Edit ${path.join(outDir, ".env.example")} (copy to .env)`);
      logger.info(`- Run: docker compose up -d --build (from ${outDir})`);
    });
}

module.exports = { registerDeployCommands };

